# HID 전송 이중 복사 해소 수정 계획 (V251010R6)

## 1. 문제 개요
- `host_keyboard_send()`가 HID IN 엔드포인트로 리포트를 전달할 때 `usbHidSendReport()`에서 먼저 전송 버퍼(`hid_buf`)로 복사한 뒤 즉시 송신을 시도합니다.【F:src/ap/modules/qmk/port/protocol/host.c†L76-L117】【F:src/hw/driver/usb/usb_hid/usbd_hid.c†L1129-L1143】
- 엔드포인트가 바쁠 경우 동일 리포트를 큐(`report_q`)에 다시 저장하고, 타이머 콜백이 큐에서 꺼내 `hid_buf`로 재복사한 뒤 재전송합니다.【F:src/hw/driver/usb/usb_hid/usbd_hid.c†L1145-L1149】【F:src/common/core/qbuffer.c†L38-L105】【F:src/hw/driver/usb/usb_hid/usbd_hid.c†L1498-L1509】
- 결과적으로 전송 실패 시 최대 세 번의 `memcpy()`가 연속 실행되어 HS 8k 폴링 환경에서 불필요한 메모리 대역폭과 CPU 시간을 소비합니다.

## 2. 현 구조 분석
1. **즉시 전송 경로**
   - 엔드포인트가 `USBD_HID_IDLE`이면 `hid_buf`로 복사 후 `USBD_HID_SendReport()` 호출이 성공하며, 큐에는 데이터가 쌓이지 않습니다.【F:src/hw/driver/usb/usb_hid/usbd_hid.c†L1138-L1144】【F:src/hw/driver/usb/usb_hid/usbd_hid.c†L849-L867】
2. **큐 적재 경로**
   - `USBD_HID_SendReport()`가 false를 반환하면 로컬 스택 구조체(`report_info`)로 다시 복사한 뒤 `qbufferWrite()`로 링 버퍼에 저장합니다.【F:src/hw/driver/usb/usb_hid/usbd_hid.c†L1145-L1149】
   - `qbufferWrite()` 구현은 슬롯 단위로 다시 한번 반복 복사를 수행하므로 총 두 번의 복사가 발생합니다.【F:src/common/core/qbuffer.c†L38-L71】
3. **재전송 경로**
   - 타이머 콜백은 큐에서 꺼낸 데이터를 또다시 `hid_buf`로 복사하고, 이후 재전송을 시도합니다.【F:src/hw/driver/usb/usb_hid/usbd_hid.c†L1498-L1509】
   - IN 완료 콜백(`USBD_HID_DataIn`)은 큐 상태를 갱신할 뿐 전송 버퍼를 다루지 않으므로, 재복사 최소화를 위해 별도의 버퍼 관리가 필요합니다.【F:src/hw/driver/usb/usb_hid/usbd_hid.c†L1029-L1047】

## 3. 수정 목표
- 전송 실패 시에도 **한 번의 메모리 복사**만으로 큐에 적재하고, 큐에서 다시 꺼낼 때 추가 복사를 하지 않는 경로를 확보합니다.
- 기존 계측 로직과 USB 모니터는 유지하면서 버퍼 수명과 정렬 제약을 준수합니다.
- `qbuffer` 공용 API 변경으로 다른 모듈에 영향을 최소화하기 위해, 하위 호환을 고려한 확장 방식으로 설계합니다.

## 4. 세부 수정 계획
### 4.1 qbuffer API 확장
1. `qbuffer_t`에 "예약된 슬롯"을 관리할 수 있는 헬퍼를 추가합니다.
   - `bool qbufferAcquire(qbuffer_t *node, uint8_t **slot)` : 가용 슬롯이 있으면 쓰기 위치 포인터를 반환하고, 인덱스만 이동합니다.
   - `void qbufferCommit(qbuffer_t *node)` : 미리 이동한 인덱스를 확정합니다.
   - `void qbufferRollback(qbuffer_t *node)` : 전송 실패 등으로 취소 시 인덱스를 원복합니다.
2. 기존 `qbufferWrite()` / `qbufferRead()`는 유지하여 호환성을 지키고, 신규 API는 zero-copy 경로가 필요한 HID 모듈에서만 사용합니다.
3. 다중 슬롯 예약이 필요한 경우를 대비해 `qbufferAcquire()` 호출 전에 `qbufferAvailable()`로 용량을 확인하도록 가이드합니다.

### 4.2 usbHidSendReport() 경로 개선
1. **단일 복사로 큐에 적재**
   - 즉시 송신을 시도하기 전에 `qbufferAcquire()`로 슬롯을 확보하고 입력 리포트를 해당 슬롯으로 한 번만 복사합니다.
   - 엔드포인트가 idle이면 확보한 슬롯 주소를 그대로 `USBD_HID_SendReport()`에 전달하고, 송신 성공 시 슬롯을 "전송 중" 상태로 마킹합니다.
2. **즉시 송신 성공 처리**
   - 전송 중인 슬롯은 IN 완료 콜백에서 `qbufferCommit()` 대신 `qbufferPop()` 형태로 소비하도록 플래그를 추가합니다.
   - `usbHidInstrumentationOnImmediateSendSuccess()`에 전달하는 큐 잔량 계산은 슬롯 예약 직후 값을 사용해 기존 로직과 동일한 통계를 유지합니다.
3. **송신 실패 처리**
   - `USBD_HID_SendReport()`가 false인 경우에는 슬롯만 커밋하고, 타이머 콜백이 해당 슬롯 주소를 그대로 사용하도록 합니다.
   - 기존처럼 스택 구조체에 임시 복사를 하지 않으므로 불필요한 `memcpy()`가 사라집니다.
4. **버퍼 수명 보장**
   - `report_buf`는 정적 배열이므로 DMA 전송 동안 유효하며, 큐가 가득 찼을 때는 `qbufferAcquire()`가 실패하도록 처리하여 기존과 동일하게 리포트 드랍 여부를 상위에서 판단할 수 있습니다.

### 4.3 재전송 및 IN 콜백 정리
1. **타이머 콜백**
   - `qbufferPeekRead()`로 확인한 슬롯 포인터를 그대로 `USBD_HID_SendReport()`에 전달하고, 추가 복사를 제거합니다.
   - 송신 성공 시 콜백 내부에서 `usbHidInstrumentationOnReportDequeued()`를 호출하여 통계를 유지합니다.
2. **USBD_HID_DataIn()**
   - IN 완료 시 현재 전송 중인 슬롯을 `qbufferPop()`(신규 함수)으로 소비하고, 잔여 큐가 있을 경우 즉시 다음 슬롯을 송신하도록 루프를 추가합니다.
   - 이때도 `hid_buf`를 사용하지 않으므로 기존 전역 버퍼는 호환성을 위해 남기되, 향후 삭제 가능 여부를 문서화합니다.
3. **예외 경로**
   - 서스펜드 상태에서 깨울 때는 기존 경로를 유지하되, 큐에 예약된 슬롯이 있다면 롤백 후 재시도하도록 처리합니다.

## 5. 예상 부작용 및 대응
| 구분 | 영향 | 대응 방안 |
| --- | --- | --- |
| **qbuffer API 변경** | 신규 함수를 추가하면서 구조체 관리가 복잡해질 수 있습니다. | 기존 API 유지, HID 모듈만 신규 API를 사용하도록 제한하며 단위 테스트(시뮬레이터)로 인덱스 롤백/커밋을 검증합니다. |
| **동시성** | 인터럽트(TIM2, USB IN)와 메인 루프 간 인덱스 경합 위험이 존재합니다. | 슬롯 상태 플래그를 `volatile`로 선언하고, 예약/커밋 연산을 크리티컬 섹션(USB 인터럽트 마스크)으로 보호합니다. |
| **전송 버퍼 정렬** | DMA가 4바이트 정렬을 요구할 경우 슬롯 주소가 어긋나면 오류가 발생할 수 있습니다. | `report_buf` 배열 정렬을 `__ALIGN_BEGIN`/`__ALIGN_END`로 보장하고, 큐 크기를 8바이트 배수로 유지합니다. |
| **계측 로직 변경** | `hid_buf` 제거 시 일부 CLI나 디버그 코드가 최신 리포트를 참조하지 못할 수 있습니다. | 초기 단계에서는 `hid_buf`를 남겨 두고, 큐 슬롯을 전송 전에 `memcpy`로 미러링하는 선택적 디버그 옵션을 제공해 회귀 여부를 확인합니다. |
| **USB 모니터 상호작용** | 폴링 지연 측정이 큐 슬롯 기반으로 변경되면 통계 산출 기준이 달라질 수 있습니다. | 계측 함수 호출 위치는 그대로 유지하고, 큐 잔량/송신 시작 시각 기록을 슬롯 메타데이터에 포함시켜 기존 결과와 비교 검증합니다. |

## 6. 적용 여부 판단
- HS 8k 환경에서 전송 실패가 빈번할 때 복사 비용이 급격히 늘어나는 현 구조는 개선 필요성이 높습니다.
- 제안한 변경은 `qbuffer` 확장을 수반하므로 단위 테스트와 USB 스택 회귀 검증이 필수지만, 구현 난이도는 중간 수준이며 다른 모듈에 미치는 영향도 제한적입니다.
- **결론적으로 V251010R6 이후 마이너 업데이트에서 도입을 권장**하며, 선행 작업으로 `qbuffer` 신규 API에 대한 테스트 케이스와 USB 통합 테스트 시나리오를 마련해야 합니다.

## 7. 즉시 전송 실패 빈도가 매우 낮은 경우의 효과 평가
- 현재 구조에서는 즉시 전송이 성공하면 `hid_buf`로의 단일 복사 이후 바로 `USBD_HID_SendReport()`가 실행되며, 큐 경로는 전혀 사용되지 않습니다.【F:src/hw/driver/usb/usb_hid/usbd_hid.c†L1138-L1144】
- 제안한 구조로 전환하면 전송 성공 시에도 큐 슬롯 확보와 메타데이터 갱신이 추가되지만, 메모리 복사 횟수는 여전히 1회로 유지되며 기존 대비 추가적인 `memcpy()`는 발생하지 않습니다.
- 즉시 전송 실패 빈도가 극히 낮다면 복사 횟수 감소에 따른 직접적인 CPU 절감 효과는 제한적입니다. 다만 다음과 같은 부가 이점이 존재합니다.
  1. **스택 복사 제거** : 실패 시 경로에서 사용되던 스택 기반 `report_info` 복사를 제거하여 스택 사용량과 캐시 쓰레싱 가능성을 줄입니다.【F:src/hw/driver/usb/usb_hid/usbd_hid.c†L1145-L1149】
  2. **큐 일관성 개선** : 큐 슬롯을 즉시 확보해 두면 전송 성공/실패 여부와 무관하게 동일한 코드 경로를 사용할 수 있어 분기 예측 부담이 줄고, 후속 유지보수 시 계측 코드를 단순화할 수 있습니다.
  3. **버퍼 핑퐁 제거** : 전송 실패가 드물더라도 재시도 시 `hid_buf`↔큐 간 복사가 반복되는 현상이 사라져, 레어 케이스에서 발생하는 지연의 분산이 줄어듭니다.
- 따라서 **즉시 전송 실패가 거의 발생하지 않는 시나리오에서는 평균 CPU 사용률 감소 폭이 미미하나**, 코드 경로 단순화와 희귀 오류 시 지연 폭 감소라는 장점이 있어 장기 유지보수 관점에서는 여전히 도입 가치가 있습니다.
