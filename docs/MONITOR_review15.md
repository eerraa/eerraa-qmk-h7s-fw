# MONITOR Review 15 (V251006R5)

## 개선안 후보 목록
1. SOF 모니터의 서스펜드 판정을 `USBD_is_suspended()` 호출 대신 `pdev->dev_state` 비교로 전환한다.
2. BootMode별 기대 폴링 간격 테이블을 `usb.c`에 통합하고, 전역 조회 함수를 제공해 중복 정의를 제거한다.
3. HID 폴링 속도 샘플 윈도우를 BootMode 변경 시에만 갱신하는 캐시를 추가해 `usbBootModeIsFullSpeed()` 호출을 제거한다.

---

### 후보 1. dev_state 기반 서스펜드 판정
- **성능 영향**: 매 SOF ISR에서 호출되던 `USBD_is_suspended()` 함수 호출을 제거하면 분기/스택 프롤로그 비용이 사라져 8kHz 루프 예산을 조금 더 확보할 수 있다. `pdev->dev_state`는 이미 레지스터에 로드되어 있어 추가 메모리 접근이 없다.
- **복잡도 영향**: 기존 조건문을 `dev_state` 비교로 치환하는 수준이라 코드 구조가 거의 변하지 않는다. 오히려 suspend/resume 경로가 한 눈에 들어와 가독성이 약간 개선된다.
- **USB 불안정성 영향**: `USBD_LL_Suspend()`가 `dev_state`를 `USBD_STATE_SUSPENDED`로 설정하므로 상태 비교만으로도 정확히 서스펜드 구간을 감지할 수 있다. Resume 시에도 Prime이 재호출되어 기존과 동일하게 워밍업이 재시작된다. 추가적인 레이스나 워밍업 스킵 위험은 없다.
- **결론**: **채택**.

### 후보 2. BootMode 기대 간격 중앙화
- **성능 영향**: 분산되어 있던 HS `bInterval`/기대 간격 테이블 중 하나를 `usb.c`로 모아 전역 함수로 노출하면 플래시 중복과 캐시 미스 가능성이 줄어든다. `usbHidExpectedPollIntervalUs()`가 테이블을 직접 들고 있지 않아도 동일한 O(1) 조회 성능을 유지한다.
- **복잡도 영향**: 공용 배열과 얇은 래퍼 함수를 추가하는 수준으로, BootMode 관련 데이터가 한 파일에서 관리되어 유지보수가 오히려 쉬워진다. 호출부는 기존 함수 호출 한 줄만 교체하면 된다.
- **USB 불안정성 영향**: 기대 간격 값 자체는 기존 테이블과 동일하다. 중앙화로 인해 잘못된 값이 반환될 가능성은 오히려 줄어들며, 모니터링·다운그레이드 로직에서 사용하는 값은 기존과 완전히 일치한다.
- **결론**: **채택**.

### 후보 3. 폴링 샘플 윈도우 캐시화
- **성능 영향**: `usbHidMeasurePollRate()`는 현재 `usbBootModeIsFullSpeed()` 비교 한 번으로 윈도우를 선택한다. 캐시를 두면 모드 변경 시만 갱신되지만, 매 호출마다 BootMode를 읽고 비교해야 하므로 총 연산량이 유사하다. 실질적인 성능 향상 폭이 미미하다.
- **복잡도 영향**: 캐시 상태와 모드 변경 감지를 위한 추가 분기가 필요해 코드가 길어지며, 리셋/다운그레이드 시 초기화를 주의해야 한다.
- **USB 불안정성 영향**: 캐시가 갱신되지 않으면 FS 전환 직후에도 HS 윈도우를 계속 사용해 통계 지표가 틀어질 수 있다. 별도 초기화 경로를 모두 커버해야 하므로 리스크가 있다.
- **결론**: **미채택**.

---

## 최종 채택 개선안
- SOF 서스펜드 감지를 `pdev->dev_state` 비교로 전환해 ISR에서의 함수 호출 오버헤드를 제거했다.
- BootMode 기대 폴링 간격 테이블을 `usb.c`로 통합하고 조회 함수를 제공해 데이터 중복을 없앴다.

## USB 불안정성 탐지 흐름 재검증 메모
1. **상태 전이 감지**: `usbHidMonitorSof()` 진입 시 `pdev->dev_state`를 단일 로드로 확보하고, 서스펜드 구간은 `USBD_STATE_SUSPENDED` 비교로 처리한다. Suspend 시 Prime이 0 홀드오프/워밍업으로 호출되고 `suspended_active`가 세트된다.
2. **Resume 복귀**: 다음 SOF에서 dev_state가 `CONFIGURED`로 돌아오면 `suspended_active` 플래그를 감지해 재 Prime하며, Resume 홀드오프(200ms)와 워밍업 타임아웃을 동일하게 적용한다. 워밍업·감쇠 캐시는 기존과 동일하게 초기화된다.
3. **안정 감시**: 워밍업 완료 이후에는 `expected_us`/`stable_threshold_us`가 16비트 캐시에서 읽히며, 간격 초과 시 `usbCalcMissedFrames()`로 누락 프레임을 계산한다. 점수 누적·감쇠·다운그레이드 트리거 로직은 변경되지 않았다.
4. **다운그레이드 큐**: 트리거 시 ISR이 포화한 누락 프레임·기대 간격을 그대로 큐에 전달하고, `usbProcess()`는 ARM/COMMIT 단계에서 동일하게 로그와 저장을 수행한다.
5. **HID 폴링 통계**: `usbHidMeasureRateTime()`은 `usbBootModeGetExpectedIntervalUs()`를 통해 중앙 테이블 값을 조회하고, 초과 지연·큐 길이 통계를 기존과 동일하게 계산한다. BootMode별 기대 간격 상수가 한 곳에서 관리되므로 로그와 큐 계산이 모두 일관성을 유지한다.

모든 경로에서 서스펜드/Resume와 다운그레이드 조건, 점수 감쇠가 의도대로 동작함을 확인했다.
