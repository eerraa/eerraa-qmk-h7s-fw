# V251010R1 WS2812 비동기 큐 전환 이후 USB 마이크로프레임 공백 원인 추론

## 1. 현상 요약
- Caps Lock LED 제어용 HID `SET_REPORT` 수신 직후 약 7.5 ms(약 60 마이크로프레임)의 USB 공백이 반복적으로 관측됩니다.
- 공백이 감지되면 USB instability monitor가 즉시 ARM 단계로 전환되어 `[NG] USB poll instability detected` 로그를 남깁니다.
- WS2812 DMA 구동을 비동기 큐(`ws2812RequestRefresh()` → `ws2812ServicePending()`)로 전환한 V251010R1 이후에도 증상이 동일하게 재현됩니다.

## 2. 호출 흐름 분석
1. 호스트가 HID `SET_REPORT`를 전송하면 `USBD_HID_EP0_RxReady()`가 USB 인터럽트 컨텍스트에서 동작합니다. 【F:src/hw/driver/usb/usb_hid/usbd_hid.c†L897-L931】
2. 위 함수는 즉시 `usbHidSetStatusLed()`를 호출하여 Caps Lock 비트 등을 넘깁니다. 【F:src/hw/driver/usb/usb_hid/usbd_hid.c†L925-L931】
3. `usbHidSetStatusLed()`는 곧바로 `led_set()`을 호출하며, 이는 인디케이터 갱신을 위해 `rgblight_set()`을 실행합니다. 【F:src/ap/modules/qmk/keyboards/era/sirind/brick60/port/led_port.c†L96-L118】【F:src/ap/modules/qmk/quantum/led.c†L144-L151】【F:src/ap/modules/qmk/quantum/rgblight/rgblight.c†L920-L964】
4. `rgblight_set()`은 모든 인디케이터/효과 버퍼를 재계산한 뒤 `rgblight_driver.setleds()` → `ws2812_setleds()`를 호출합니다. 이 내부에서는 각 LED 색상 갱신과 WS2812 프레임 버퍼 복사가 이뤄집니다. 【F:src/ap/modules/qmk/quantum/rgblight/rgblight.c†L920-L1000】【F:src/ap/modules/qmk/keyboards/era/sirind/brick60/port/driver/rgblight_drivers.c†L4-L22】
5. 최종적으로 `ws2812_setleds()`는 `ws2812SetColor()`를 반복 호출하며 WS2812 프레임 버퍼를 갱신한 뒤 비동기 큐에 새 DMA 프레임을 등록합니다. 【F:src/ap/modules/qmk/keyboards/era/sirind/brick60/port/driver/rgblight_drivers.c†L4-L22】【F:src/hw/driver/ws2812.c†L195-L223】【F:src/hw/driver/ws2812.c†L264-L320】

## 3. 원인 추론
- WS2812 DMA 재기동은 비동기 큐로 분리되었으나, RGB 계산과 WS2812 프레임 버퍼 갱신 자체는 `usbHidSetStatusLed()` 호출 시점에 모두 수행됩니다.
- `USBD_HID_EP0_RxReady()`가 USB ISR 컨텍스트에서 실행되므로, Caps Lock LED 업데이트 동안 수백 μs~수 ms의 루프가 인터럽트 컨텍스트에서 지속됩니다.
- 특히 `rgblight_set()`은 최대 60개 인디케이터 LED에 대한 HSV→RGB 변환, 레이어 합성, 버퍼 복사, RGBW 변환 등을 모두 처리합니다. WS2812 DMA만 비동기로 바뀌어도 이 계산 구간은 여전히 인터럽트 내부에서 유지됩니다.
- 그 결과 EP0 인터럽트가 약 7.5 ms 동안 점유되고, 다른 USB 마이크로프레임 서비스가 중단되어 instability monitor가 폴링 공백을 검출합니다.
- 즉, **핵심 병목은 WS2812 DMA 구동이 아니라 호스트 LED 갱신 로직 전체가 인터럽트 컨텍스트에서 동작한다는 점**으로 판단됩니다.

## 4. 수정 제안
1. `usbHidSetStatusLed()`를 완전히 비동기화합니다.
   - ISR에서는 단순히 `host_led_state`와 `pending` 플래그만 갱신하도록 축소합니다.
   - 구체적으로 `volatile uint8_t host_led_pending_bits`와 `volatile bool host_led_dirty`를 두고, ISR은 `host_led_pending_bits = led_bits; host_led_dirty = true;`만 수행하도록 합니다.
2. 메인 루프(`keyboard_task()` 말미 혹은 `led_task()`)에서 `host_led_dirty`를 폴링하여 `led_set()` → `rgblight_set()`을 호출합니다.
   - 이미 WS2812 DMA는 메인 루프에서 처리되므로 LED 계산·버퍼 복사 역시 같은 위치로 옮기는 것이 자연스럽습니다.
   - 이 때 `host_led_dirty`는 크리티컬 섹션 보호(예: `__disable_irq()`/`__enable_irq()` 또는 `ws2812RestorePrimask()` 재활용)로 클리어합니다.
3. 필요 시 USB HID 계층과 키보드 포트 사이에 전용 이벤트 큐(1-depth 또는 소량) 도입을 검토합니다.
   - 다중 `SET_REPORT` 수신 시 마지막 상태만 유지하면 충분하지만, 확장 호스트 LED가 추가될 가능성에 대비해 작은 링 버퍼(예: 4-depth)를 고려합니다.
4. 수정 후 검증 계획
   - SOF 모니터로 Caps Lock 토글 시 USB 마이크로프레임 공백이 1 프레임 이하(125 μs 수준)인지 확인합니다.
   - USB instability monitor가 다운그레이드 큐를 ARM 단계로 전환하지 않는지 로그 확인합니다.
   - WS2812 색상 갱신이 정상적으로 적용되는지 육안 및 CLI(`ws2812` 테스트 명령)로 확인합니다.

## 5. 기대 효과
- USB ISR에서의 고비용 연산을 제거하여 HS 8 kHz 폴링 루프가 안정적으로 유지됩니다.
- WS2812 비동기 큐 구조와 호스트 LED 처리 경로가 일관되게 메인 루프 중심으로 정리되어 향후 유지보수가 용이해집니다.
- Caps Lock 등 호스트 LED 입력에 따른 반응성은 USB 프레임 한 주기 수준의 지연으로 충분히 수용 가능하며, 대신 USB 연결 안정성을 확보할 수 있습니다.