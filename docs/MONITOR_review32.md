# MONITOR Review 32 (V251008R4)

## 후보 1: BootMode 파생 간격 캐시
- 성능 영향: `usbBootModeGetHsInterval()`과 `usbBootModeGetExpectedIntervalUs()`가 호출될 때마다 테이블을 재조회하고 있었는데, BootMode 변경은 드물고 조회는 ISR/CLI 등에서 반복된다. BootMode가 바뀌는 시점에만 HS `bInterval`과 기대 폴링 간격을 캐시하면 반복 조회가 단순한 메모리 읽기 한 번으로 줄어든다.
- 복잡도 영향: 테이블 값을 보관하는 정적 변수 두 개와 `usbBootModeRefreshCaches()` 헬퍼가 추가된다. BootMode 로드·저장 경로에서 헬퍼를 호출하기만 하면 돼 제어 흐름 변화가 없다.
- USB 불안정성 탐지 영향: 캐시는 BootMode가 바뀔 때마다 갱신되며, 다운그레이드 큐도 `usbBootModeGetExpectedIntervalUs()`를 통해 동일 값을 이용한다. 잘못된 값이 유지될 위험이 없고, 탐지 로직이 사용하는 기대 간격도 그대로 유지된다.
- 결론: 채택한다.

## 후보 2: 폴링 속도 진단에서 기대 간격 캐시 재사용
- 성능 영향: `usbHidMeasureRateTime()`은 폴링 간격을 측정할 때마다 `usbHidExpectedPollIntervalUs()`를 호출한다. BootMode가 바뀐 직후에만 기대 간격을 다시 계산하고, 이후에는 캐시된 값을 읽으면 ISR 수준에서 함수 호출과 테이블 접근을 피할 수 있다.
- 복잡도 영향: `usbHidMeasurePollRate()` 내부에 기대 간격 캐시를 갱신하는 한 줄이 추가되고, 측정 루프에서는 이미 존재하는 정적 변수를 읽기만 하면 된다. 기존 흐름을 크게 바꾸지 않는다.
- USB 불안정성 탐지 영향: SOF 모니터와 다운그레이드 판단은 여전히 `usbBootModeGetExpectedIntervalUs()`에서 가져온 값을 사용한다. 폴링 속도 진단은 보조 통계이므로 캐시 사용이 감지 로직에 부정적 영향을 주지 않는다.
- 결론: 채택한다.

## 후보 3: SOF ISR에서 속도 유효성 계산을 상태 전환 처리 뒤로 이동
- 성능 영향: 현재는 ISR 초기에 `pdev->dev_speed`를 읽고 HS/FS 비교를 한 뒤 상태 전환을 검사한다. 비교를 상태 전환 처리 이후로 미루면 상태가 바뀌는 드문 프레임에서만 소폭의 연산을 줄일 수 있지만, 평상시(구성 상태)에는 동일 횟수의 비교가 실행돼 이득이 미미하다.
- 복잡도 영향: `speed_valid` 계산 위치를 바꾸면 서스펜드·속도 변경 분기마다 조건을 재작성해야 해 코드 가독성이 떨어진다.
- USB 불안정성 탐지 영향: 계산 순서를 잘못 맞추면 서스펜드 첫 프레임에서 속도 파라미터가 갱신되지 않는 회귀가 생길 수 있다. 검증 비용 대비 기대 이득이 적다.
- 결론: 보류한다.
