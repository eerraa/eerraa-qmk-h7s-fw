# V251009R3 BRICK60 LED 포트 리팩토링 리뷰 2

## 개선안 1: HSV→RGB 변환 캐시 도입
### 변경 전/후 비교
- 변경 전: `rgblight_indicators_kb()`가 호출될 때마다 각 인디케이터별로 `hsv_to_rgb()`를 실행하여 동일한 색상을 반복 계산했다.
- 변경 후: `led_config`가 갱신될 때에만 RGB를 재계산하도록 캐시(`indicator_rgb_cache`, `indicator_rgb_dirty`)를 도입하고, 표시 루프에서는 캐시된 값을 즉시 사용한다.

### 기대 이득
- 반복적인 `hsv_to_rgb()` 호출이 제거되어 인디케이터 표시 호출 빈도가 높을 때 CPU 부하가 감소한다.
- 동일한 색상 정보를 여러 함수에서 일관되게 사용할 수 있어 추후 기능 확장 시 재사용성이 향상된다.

### 잠재 부작용
- 색상 캐시와 동기화되지 않은 상태에서 외부에서 `led_config`가 직접 수정되면 색상이 즉시 반영되지 않을 수 있다. (현재 포트에서는 모든 갱신이 포팅 레이어에서만 이뤄지므로 영향 없음)

### 적용 여부
- **적용**: `led_config` 접근 경로가 제한되어 있어 캐시 유지 비용이 낮고 성능 향상 효과가 확실하다.

## 개선안 2: 인디케이터 LED 범위 상한 사전 계산 필드 추가
### 변경 전/후 비교
- 변경 전: 각 표시 루프에서 `start + count` 연산 후 `RGBLIGHT_LED_COUNT`로 클램프한다.
- 변경 후: 초기화 시 `limit` 값을 계산해 `indicator_profile_t`에 저장하면 표시 루프에서 덧셈과 비교를 생략할 수 있다.

### 기대 이득
- 루프 내부에서 수행하던 덧셈 및 분기 연산을 제거하여 소폭의 실행 시간을 절약할 수 있다.

### 잠재 부작용
- `RGBLIGHT_LED_COUNT`가 조건부 컴파일로 변동될 때 초기화 위치를 조정해야 하며, 프로파일 구조체 정의를 수정해야 한다.
- 기존 테이블을 사용하는 다른 코드가 있을 경우 구조체 크기 변경으로 재컴파일 오류가 발생할 수 있다.

### 적용 여부
- **보류**: 현재 루프는 3개 인디케이터만 처리하며 연산 비용이 매우 낮으므로 코드 구조 변경 대비 이득이 제한적이다.

## 개선안 3: LED 타입 유효성 검사 헬퍼 함수 도입
### 변경 전/후 비교
- 변경 전: 각 퍼블릭/프라이빗 함수 시작부에서 `if (led_type >= LED_TYPE_MAX_CH)` 검사를 반복한다.
- 변경 후: `static bool led_type_valid(uint8_t led_type)` 헬퍼를 도입해 가독성과 중복 코드를 줄인다.

### 기대 이득
- 입력 검증 로직이 단일 함수에 집중되어 코드 가독성이 높아지고 추후 LED 타입 확장 시 유지보수가 쉬워진다.

### 잠재 부작용
- 인라인 되지 않을 경우 호출 오버헤드가 미세하게 증가할 수 있다.
- 코드 스타일상 간단한 비교를 함수로 분리하는 것이 과도한 추상화로 인식될 수 있다.

### 적용 여부
- **현행 유지**: 비교 로직이 간단해 함수 분리로 인한 이득이 제한적이며, 캐시 도입 외의 변경은 최소화한다.
