# 키 스캔 경로 최적화 검토 (V250924R6)

## 1. 분석 범위와 기준
- **측정 기준**: `matrix info on` CLI에서 노출되는 `SCAN RATE` 및 `Scan Time`.
- **대상 경로**: `matrix_scan()` → `keysPeekColsBuf()` → DMA 기반 `col_rd_buf` → 디바운서(`sym_defer_pk`, `sym_eager_pk`, `asym_eager_defer_pk`).
- **현황**: USB 불안정성 탐지 로직 도입 이후 스캔 레이트가 약 5% 하락.

## 2. 기존 구현 요약
1. `keysReadColsBuf()`로 DMA 버퍼 전체를 지역 배열에 복사.
2. 각 행을 순회하며 `raw_matrix`와 비교, 변경 시 갱신 및 `changed=true`.
3. 결과를 디바운서에 전달하여 QMK 매트릭스 상태를 확정.

### 구현 의도 해석
- DMA가 채운 `col_rd_buf`를 즉시 복사해 스냅샷을 확보하고, 디바운서 호출 전에 일관된 데이터를 보장하려는 목적.
- `changed` 플래그를 통해 디바운서의 시간 업데이트와 USB 타임 로그 호출 빈도를 조절.

## 3. 발견된 병목
- 매 스캔마다 `MATRIX_ROWS*sizeof(uint16_t)` 만큼의 `memcpy`가 발생.
- DMA 버퍼는 `.non_cache` 섹션에 위치해 있으며, CPU가 직접 참조해도 캐시 일관성 문제가 없음.
- 추가 복사 없이도 동일한 데이터 일관성을 유지할 수 있어, 8000Hz 환경에서는 `memcpy` 제거 효과가 누적.

## 4. 개선안
| 구분 | 기존 | 개선 |
|------|------|------|
| 데이터 취득 | `keysReadColsBuf()` → 지역 배열 복사 | `keysPeekColsBuf()`로 DMA 버퍼 직접 참조 |
| 변경 감지 | `raw_matrix` vs 지역 배열 | `raw_matrix` vs DMA 버퍼 |
| 디바운서 호환성 | `changed` 플래그 전달 | 동일 (`changed` 계산 로직 유지) |

- DMA 버퍼를 상수 포인터로 노출하는 `keysPeekColsBuf()` 신규 API 추가.
- `matrix_scan()`은 포인터를 통해 행 데이터를 바로 읽고 변경 여부를 판단.
- 디바운서 API (`sym_defer_pk`, `sym_eager_pk`, `asym_eager_defer_pk`)는 입력 배열 참조 방식이 그대로라 호환성 유지.

## 5. 부작용 검토
- **동시성**: DMA가 16비트 단위로 버퍼를 갱신하며, CPU도 16비트로 읽으므로 절반만 갱신된 값을 읽을 확률은 매우 낮음. 기존 `memcpy` 또한 동일한 윈도우에서 실행되므로 위험 수준은 동일.
- **API 의존성**: 기존 호출부(`keysReadColsBuf`)는 유지되어 다른 모듈 영향 없음.
- **디바운서 동작**: 입력 포인터만 변경되었으므로 타이머 기반 동작 (`changed` 전달) 불변.

## 6. 수정/유지 판단
- **수정 필요**: `matrix_scan()`에서 DMA 버퍼 직접 참조로 전환, 새로운 API 제공, 펌웨어 버전 갱신.
- **유지 항목**: 디바운스 로직 호출 구조, `changed` 플래그 처리, USB 타임 로그 호출 조건.

## 7. 기대 효과
- 키 스캔 루프의 메모리 복사 비용 제거로 8000Hz 환경에서 약 3~4% 수준의 스캔 시간 회복 기대 (DMA/CPU 경합 상황에서 추가 이득 가능).
- USB 불안정성 탐지 로직으로 발생한 스캔 레이트 하락분을 상당 부분 상쇄.

## 8. 키 이벤트 처리 경로 추가 분석 (V250924R6)

### 8.1 경로 추적 및 기존 동작 요약
- **탐색 범위**: `keyboard_task()` → `matrix_task()` → `matrix_scan()` → `action_exec()`.
- `matrix_task()`은 매 스캔마다 `matrix_scan()`을 호출한 뒤, `matrix_previous` 배열과의 XOR 결과를 이용해 행 단위 변경 여부를 확인하고, 변경이 감지된 행만 열 루프를 돌며 키 이벤트를 생성.
- 고스트(phantom) 상태가 감지되면 해당 행 처리를 건너뛰고 `matrix_previous`를 갱신하지 않아, 고스트가 해소될 때까지 이후 반복에서 계속 변경으로 인식되는 구조.

### 8.2 개선안 vs 기존 코드 비교
| 구분 | 기존 | 개선 (V250924R6) |
|------|------|-----------------|
| 변경 감지 초기화 | `matrix_scan()` 결과와 무관하게 모든 행을 순회하며 XOR 검사 | `matrix_scan()` 반환값을 1차 신호로 사용, 고스트 상태 여부(`ghost_pending`)를 보강 지표로 활용 |
| 고스트 지속 처리 | 고스트가 존재하면 `matrix_previous` 미갱신 → 다음 스캔도 전체 행 검사 | 고스트 플래그가 설정된 경우에만 후속 스캔에서 행 검사를 유지 |
| 불필요한 루프 | 키 상태 변화가 없더라도 `MATRIX_ROWS` 전부 순회 | 고스트가 없고 스캔 결과가 동일하면 행 루프 자체를 건너뜀 |

### 8.3 기존 구현 의도 해석
- 고속 폴링 환경에서 **디바운스 이후 상태 변화**를 감지해 필요할 때만 `action_exec()`을 호출하려는 목적.
- 고스트가 발견되면 `matrix_previous`를 고의로 유지해, 고스트가 사라질 때까지 매트릭스 변경이 반복적으로 보고되도록 설계하여 안정적인 해제 이벤트를 확보하려는 의도.

### 8.4 부작용 검토
- `matrix_scan()` 결과가 false라도 고스트 지속 여부에 따라 다시 행 루프가 실행되므로, 고스트 시나리오에서 기존과 동일하게 해제 감시가 이루어짐.
- `ghost_pending` 플래그가 없는 상태에서는 행 루프를 건너뛰지만, 이는 `matrix_previous`와 디바운스 결과가 이미 동기화된 상황에서만 발생하므로 이벤트 누락 없음.
- `matrix_task()` 반환값은 기존과 동일하게 고스트를 포함한 변경 케이스에서 true를 유지하여, `last_matrix_activity_trigger()` 호출 빈도 변화 없음.

### 8.5 수정/유지 판단
- **수정 필요**: 고스트 지속 플래그(`ghost_pending`)를 도입하고, `matrix_scan()` 결과 기반으로 행 루프 수행 여부를 단축하여 무의미한 XOR 루프를 제거.
- **유지 항목**: 고스트 발생 시 `matrix_previous` 미갱신 전략, `should_process_keypress()` 게이트, `switch_events()` 후속 훅 구조.

