# 키 스캔 경로 최적화 검토 (V250924R7)

## 1. V250924R5: DMA 버퍼 직접 참조 전환

### 1.1 현황
- `matrix info on` 기준 스캔 레이트가 USB 진단 로직 추가 후 약 5% 하락.
- 경로: `matrix_scan()` → `keysReadColsBuf()` → `col_rd_buf` → 디바운서.

### 1.2 문제 원인
- 매 스캔마다 DMA 버퍼를 지역 배열로 `memcpy`.
- 버퍼는 `.non_cache` 영역이라 직접 참조해도 캐시 이슈가 없음.

### 1.3 개선 방향
| 구분 | 기존 | 개선안 |
|------|------|--------|
| 데이터 취득 | `keysReadColsBuf()`로 복사 | `keysPeekColsBuf()`로 포인터 획득 |
| 변경 감지 | 지역 배열 vs `raw_matrix` | DMA 버퍼 vs `raw_matrix` |
| 부가 처리 | `changed` 전달 | 동일 |

- `keysPeekColsBuf()` API로 DMA 버퍼를 const 포인터로 노출.
- `matrix_scan()`은 복사 없이 바로 비교 후 디바운서 호출.

### 1.4 영향 평가
- 추가 동시성 리스크 없음(16비트 단위 갱신/읽기 동일).
- 기존 `keysReadColsBuf()` 호출부는 유지돼 외부 영향 최소.
- 스캔 루프의 `memcpy` 제거로 8000Hz 환경에서 3~4% 시간 회복 기대.

### 1.5 결정
- **수정**: DMA 직접 참조 전환 및 신규 API 도입.
- **유지**: 디바운스 흐름, `changed` 플래그, USB 타임 로그 조건.

## 2. V250924R6: `matrix_task()` 행 루프 단축

### 2.1 현황
- 경로: `keyboard_task()` → `matrix_task()` → `matrix_scan()` → `action_exec()`.
- 변화가 없을 때도 모든 행을 XOR 비교하며 열 루프까지 진입.
- 고스트가 발생하면 `matrix_previous`를 갱신하지 않아 이후에도 전 행을 반복 검사.

### 2.2 개선 방향
| 구분 | 기존 | 개선안 |
|------|------|--------|
| 루프 진입 | 매번 `MATRIX_ROWS` 순회 | `matrix_scan()` 결과가 true일 때만 기본 진입 |
| 고스트 처리 | 고스트 시에도 전체 행 재검사 | `ghost_pending`이 true인 경우에만 재진입 |
| 결과 플래그 | 모든 경우 true 반환 | 변경/고스트 시에만 true 유지 |

- `ghost_pending` 플래그를 도입해 필요 시에만 행 루프 유지.
- 이벤트 흐름(`should_process_keypress()`, `switch_events()`)은 그대로 사용.

### 2.3 영향 평가
- 고스트 존재 시 기존과 동일하게 반복 검사하므로 해제 감시 누락 없음.
- 변화가 없고 고스트도 없으면 행 루프를 건너뛰어 불필요한 XOR/분기를 제거.

### 2.4 결정
- **수정**: `matrix_scan()` 반환 및 `ghost_pending` 기반으로 행 루프 단축.
- **유지**: 고스트 발생 시 `matrix_previous` 미갱신 전략과 후속 훅 구조.

## 3. V250924R7: 열 루프 비트 스캔 최적화

### 3.1 현황
- `matrix_task()` 열 루프가 `MATRIX_COLS` 회 고정 반복.
- `row_changes`에 1~2비트만 있어도 조건 검사와 시프트가 계속 수행됨.

### 3.2 개선 방향
| 구분 | 기존 | 개선안 |
|------|------|--------|
| 반복 횟수 | 고정 for-loop | set bit만 순회 |
| 비트 처리 | 시프트 + AND 분기 | `__builtin_ctz()` + `pending &= pending - 1` |
| 메모리 접근 | 전 열 검사 후 이벤트 처리 | 이벤트가 있는 열만 처리 |

- `row_changes`를 비트 스캔하면서 열 인덱스를 추출.
- 처리한 비트는 `pending_changes &= pending_changes - 1`로 제거.

### 3.3 영향 평가
- 입력이 적을수록 시프트/분기 횟수 감소.
- `matrix_row_t` 정의와 이벤트 순서는 기존과 동일.
- `__builtin_ctz()`는 ARM-GCC에서 지원하며 0 입력은 루프 조건으로 차단.

### 3.4 결정
- **수정**: 열 루프를 비트 스캔 기반으로 교체.
- **유지**: `process_keypress`, `switch_events()`, 고스트 행 스킵 로직.

## 4. V250924R8: 고스트 검출 조기 종료 최적화

### 4.1 현황
- 경로: `keyboard_task()` → `matrix_task()` → `has_ghost_in_row()` → `get_real_keys()`.
- 행에서 비트 변화가 있으면 열 전체를 순회하며 키맵을 매번 조회.
- 대부분의 입력은 0~1키라 불필요한 순회가 반복됨.

### 4.2 개선 방향
| 구분 | 기존 | 개선안 |
|------|------|--------|
| 초기 분기 | 행 데이터와 무관하게 `get_real_keys()` 실행 | 물리 비트가 0/1이면 즉시 반환 |
| 키맵 조회 | 항상 전체 열 검사 | 2키 이상일 때만 수행 |
| 성능 영향 | 단일 키에서도 키맵 순회 비용 발생 | 대부분의 스캔에서 호출 한 번으로 종료 |

- 물리 행 데이터의 비트 수를 먼저 확인해 0/1이면 곧바로 반환.
- 2키 이상이면 기존과 동일하게 키맵 필터링을 수행.

### 4.3 영향 평가
- 고스트는 최소 2키 이상에서만 발생하므로 조기 종료로 누락 없음.
- 동적 키맵(VIA/Vial)도 동일 API를 사용해 호환성 유지.
- `ghost_pending` 흐름과 후속 이벤트 구조는 그대로 유지.

### 4.4 결정
- **수정**: 0/1키 입력 시 `get_real_keys()` 호출 생략.
- **유지**: 고스트 판정 로직, `switch_events()`, 디바운스 연계 구조.

## 5. V250928R1: 키맵 열 순회 단축으로 고스트 판정 가속

### 5.1 입력 흐름 및 기존 동작 재검토
- **추적 경로**: `keyboard_task()` → `matrix_task()` → `has_ghost_in_row()` → `get_real_keys()` → `keycode_at_keymap_location()`.
- **현상**: `get_real_keys()`가 호출될 때마다 모든 열(`MATRIX_COLS`)을 순회하며 키맵을 조회하고, 해당 위치에 키가 정의되어 있는지 확인.
- **문제점**: 실제로는 `rowdata`에서 set된 비트(현재 눌린 스위치)만 검증하면 되지만, 매번 전체 열을 확인해 불필요한 함수 호출과 분기 비용이 발생.

### 5.2 개선안과 오리지널 코드 비교
| 구분 | 기존 구현 | 개선안(V250928R1) |
|------|-----------|-------------------|
| 열 순회 방식 | `for (col = 0; col < MATRIX_COLS; col++)` | `while (pending_columns)`으로 set bit만 순회 |
| 키맵 조회 횟수 | 항상 `MATRIX_COLS` | 실제 눌린 키 수만큼 |
| 비트 처리 | 시프트(`<<`)와 AND 조건 반복 | `__builtin_ctz`와 `pending &= pending - 1`로 O(#pressed) 반복 |

### 5.3 오리지널 의도 분석
- 키맵에 정의된 실제 키만 남겨 고스트 판정을 수행해, 미할당 위치(KC_NO)를 무시하려는 목적.
- 모든 열을 순회하는 단순 구조로 가독성을 확보하고, 다양한 `MATRIX_COLS` 설정에서도 동일한 동작을 보장.

### 5.4 부작용 검토
- **동적 키맵 호환성**: 여전히 `keycode_at_keymap_location()`을 호출해 최신 키맵 데이터를 참조하므로, VIA/Vial을 통한 실시간 레이아웃 변경과 충돌 없음.
- **컴파일러 의존성**: `__builtin_ctz`는 ARM-GCC에서 지원하며, 입력 값이 0인 경우는 루프 진입 조건으로 배제되어 안전.
- **고스트 판정 정확도**: 필터링 대상 열만 축소했을 뿐 반환 값은 기존과 동일하여 `has_ghost_in_row()`와 후속 로직이 그대로 동작.

### 5.5 수정/유지 판단
- **수정 필요**: `rowdata`에서 실제로 눌린 열만 순회하도록 비트 스캔 방식을 도입해, 대부분의 스캔(0~1키 입력)에서 불필요한 키맵 조회를 제거.
- **유지 항목**: 키맵 필터링 조건, `popcount_more_than_one()` 사용, 행 비교 및 `ghost_pending` 흐름은 기존 의도대로 보존.

## 6. V250928R2: 고스트 판정 시 물리 중복 열 기반의 키맵 필터 최소화

### 6.1 입력 흐름 재점검
- **추적 경로**: `keyboard_task()` → `matrix_task()` → `has_ghost_in_row()` → `get_real_keys()` → `keycode_at_keymap_location()`.
- **현상**: 특정 행(`rowdata`)에서 2키 이상이 눌린 경우, 다른 모든 행에 대해 `get_real_keys()`를 호출한다. 이때 물리적으로 공유하는 열이 2개 미만이더라도 키맵 필터를 수행해 불필요한 순회가 발생한다.

### 6.2 개선안(V250928R2)
| 구분 | 기존 구현 | 개선안 |
|------|-----------|--------|
| 중복 열 판단 | 즉시 `get_real_keys()` 호출 | 물리 행 데이터와 `rowdata`의 교집합을 먼저 계산 |
| 필터 조건 | 항상 키맵 필터 수행 | 물리 중복 열이 2개 이상일 때만 키맵 필터 수행 |
| 추가 연산 | 없음 | `overlap`에 대한 1비트 이하 빠른 종료 |

### 6.3 오리지널 의도 분석
- 고스트는 동일한 두 열이 두 개 이상의 행에서 동시에 활성화될 때만 발생한다는 전제를 유지.
- `get_real_keys()`로 미할당 키를 제거해, 실질적으로 사용자가 접근 가능한 키만 남기는 목적은 그대로 필요.

### 6.4 부작용 검토
- **고스트 누락 가능성**: 물리 중복 열이 2개 미만이면 직사각형을 이루지 못해 고스트가 발생하지 않으므로 안전하게 건너뛸 수 있다.
- **동적 키맵 호환성**: 키맵 필터를 완전히 제거하지 않고 조건부로 수행하므로 VIA/Vial 변경과 동일하게 동작한다.
- **성능 효과**: 대부분의 스캔에서 행 간 중복 열이 없으므로 `get_real_keys()` 호출 수가 크게 감소한다.

### 6.5 수정/유지 판단
- **수정 필요**: 물리 중복 열이 2개 미만인 경우 조기 종료를 도입해 키맵 필터링 호출을 줄인다.
- **유지 항목**: 고스트 판정 조건(`popcount_more_than_one()`), `ghost_pending` 처리 흐름, 이벤트 디스패치 구조는 기존 구현을 따른다.
