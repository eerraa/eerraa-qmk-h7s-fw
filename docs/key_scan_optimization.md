# 키 스캔 경로 최적화 검토 (V250924R7)

## 1. V250924R5: DMA 버퍼 직접 참조 전환

### 1.1 현황
- `matrix info on` 기준 스캔 레이트가 USB 진단 로직 추가 후 약 5% 하락.
- 경로: `matrix_scan()` → `keysReadColsBuf()` → `col_rd_buf` → 디바운서.

### 1.2 문제 원인
- 매 스캔마다 DMA 버퍼를 지역 배열로 `memcpy`.
- 버퍼는 `.non_cache` 영역이라 직접 참조해도 캐시 이슈가 없음.

### 1.3 개선 방향
| 구분 | 기존 | 개선안 |
|------|------|--------|
| 데이터 취득 | `keysReadColsBuf()`로 복사 | `keysPeekColsBuf()`로 포인터 획득 |
| 변경 감지 | 지역 배열 vs `raw_matrix` | DMA 버퍼 vs `raw_matrix` |
| 부가 처리 | `changed` 전달 | 동일 |

- `keysPeekColsBuf()` API로 DMA 버퍼를 const 포인터로 노출.
- `matrix_scan()`은 복사 없이 바로 비교 후 디바운서 호출.

### 1.4 영향 평가
- 추가 동시성 리스크 없음(16비트 단위 갱신/읽기 동일).
- 기존 `keysReadColsBuf()` 호출부는 유지돼 외부 영향 최소.
- 스캔 루프의 `memcpy` 제거로 8000Hz 환경에서 3~4% 시간 회복 기대.

### 1.5 결정
- **수정**: DMA 직접 참조 전환 및 신규 API 도입.
- **유지**: 디바운스 흐름, `changed` 플래그, USB 타임 로그 조건.

### 1.6 재검토 결과
- DMA 버퍼를 직접 읽는 경로에서 `volatile`이 없으면 컴파일러가 값을 캐시해 DMA 갱신을 놓칠 수 있음을 확인했다.
- `col_rd_buf`를 `volatile`로 지정하고 `keysPeekColsBuf()`가 `const volatile` 포인터를 반환하도록 보완해, 스캔 시점마다 최신 값을 안정적으로 취득하도록 수정했다.

## 2. V250924R6: `matrix_task()` 행 루프 단축

### 2.1 현황
- 경로: `keyboard_task()` → `matrix_task()` → `matrix_scan()` → `action_exec()`.
- 변화가 없을 때도 모든 행을 XOR 비교하며 열 루프까지 진입.
- 고스트가 발생하면 `matrix_previous`를 갱신하지 않아 이후에도 전 행을 반복 검사.

### 2.2 개선 방향
| 구분 | 기존 | 개선안 |
|------|------|--------|
| 루프 진입 | 매번 `MATRIX_ROWS` 순회 | `matrix_scan()` 결과가 true일 때만 기본 진입 |
| 고스트 처리 | 고스트 시에도 전체 행 재검사 | `ghost_pending`이 true인 경우에만 재진입 |
| 결과 플래그 | 모든 경우 true 반환 | 변경/고스트 시에만 true 유지 |

- `ghost_pending` 플래그를 도입해 필요 시에만 행 루프 유지.
- 이벤트 흐름(`should_process_keypress()`, `switch_events()`)은 그대로 사용.

### 2.3 영향 평가
- 고스트 존재 시 기존과 동일하게 반복 검사하므로 해제 감시 누락 없음.
- 변화가 없고 고스트도 없으면 행 루프를 건너뛰어 불필요한 XOR/분기를 제거.

### 2.4 결정
- **수정**: `matrix_scan()` 반환 및 `ghost_pending` 기반으로 행 루프 단축.
- **유지**: 고스트 발생 시 `matrix_previous` 미갱신 전략과 후속 훅 구조.

### 2.5 재검토 결과
- `ghost_pending`이 true인 동안 행 루프가 강제로 유지돼 고스트 해제 시점에도 `matrix_previous`가 정상적으로 갱신되는지 확인했다.
- 고스트가 없는 경우에만 루프를 건너뛰므로 이벤트 누락 위험이 없어 추가 보완은 불필요하다.

## 3. V250924R7: 열 루프 비트 스캔 최적화

### 3.1 현황
- `matrix_task()` 열 루프가 `MATRIX_COLS` 회 고정 반복.
- `row_changes`에 1~2비트만 있어도 조건 검사와 시프트가 계속 수행됨.

### 3.2 개선 방향
| 구분 | 기존 | 개선안 |
|------|------|--------|
| 반복 횟수 | 고정 for-loop | set bit만 순회 |
| 비트 처리 | 시프트 + AND 분기 | `__builtin_ctz()` + `pending &= pending - 1` |
| 메모리 접근 | 전 열 검사 후 이벤트 처리 | 이벤트가 있는 열만 처리 |

- `row_changes`를 비트 스캔하면서 열 인덱스를 추출.
- 처리한 비트는 `pending_changes &= pending_changes - 1`로 제거.

### 3.3 영향 평가
- 입력이 적을수록 시프트/분기 횟수 감소.
- `matrix_row_t` 정의와 이벤트 순서는 기존과 동일.
- `__builtin_ctz()`는 ARM-GCC에서 지원하며 0 입력은 루프 조건으로 차단.

### 3.4 결정
- **수정**: 열 루프를 비트 스캔 기반으로 교체.
- **유지**: `process_keypress`, `switch_events()`, 고스트 행 스킵 로직.

### 3.5 재검토 결과
- `while (pending_changes)` 조건으로 0 입력이 배제되어 `__builtin_ctz()` 호출이 안전한지 검증했다.
- 열 이벤트 처리 순서와 `switch_events()` 연계가 기존과 동일하게 유지돼 추가 변경이 필요하지 않다.

## 4. V250924R8: 고스트 검출 조기 종료 최적화

### 4.1 현황
- 경로: `keyboard_task()` → `matrix_task()` → `has_ghost_in_row()` → `get_real_keys()`.
- 행에서 비트 변화가 있으면 열 전체를 순회하며 키맵을 매번 조회.
- 대부분의 입력은 0~1키라 불필요한 순회가 반복됨.

### 4.2 개선 방향
| 구분 | 기존 | 개선안 |
|------|------|--------|
| 초기 분기 | 행 데이터와 무관하게 `get_real_keys()` 실행 | 물리 비트가 0/1이면 즉시 반환 |
| 키맵 조회 | 항상 전체 열 검사 | 2키 이상일 때만 수행 |
| 성능 영향 | 단일 키에서도 키맵 순회 비용 발생 | 대부분의 스캔에서 호출 한 번으로 종료 |

- 물리 행 데이터의 비트 수를 먼저 확인해 0/1이면 곧바로 반환.
- 2키 이상이면 기존과 동일하게 키맵 필터링을 수행.

### 4.3 영향 평가
- 고스트는 최소 2키 이상에서만 발생하므로 조기 종료로 누락 없음.
- 동적 키맵(VIA/Vial)도 동일 API를 사용해 호환성 유지.
- `ghost_pending` 흐름과 후속 이벤트 구조는 그대로 유지.

### 4.4 결정
- **수정**: 0/1키 입력 시 `get_real_keys()` 호출 생략.
- **유지**: 고스트 판정 로직, `switch_events()`, 디바운스 연계 구조.

### 4.5 재검토 결과
- 조기 종료 조건이 물리 입력 기준이라 VIA/Vial 등 동적 키맵에서도 고스트 누락 없이 적용됨을 확인했다.
- 2키 이상에서만 키맵 필터를 호출해 기존 동작과 호환되므로 추가 보완이 필요 없다.

## 5. V250928R1: 키맵 열 순회 단축으로 고스트 판정 가속

### 5.1 입력 흐름 및 기존 동작 재검토
- **추적 경로**: `keyboard_task()` → `matrix_task()` → `has_ghost_in_row()` → `get_real_keys()` → `keycode_at_keymap_location()`.
- **현상**: `get_real_keys()`가 호출될 때마다 모든 열(`MATRIX_COLS`)을 순회하며 키맵을 조회하고, 해당 위치에 키가 정의되어 있는지 확인.
- **문제점**: 실제로는 `rowdata`에서 set된 비트(현재 눌린 스위치)만 검증하면 되지만, 매번 전체 열을 확인해 불필요한 함수 호출과 분기 비용이 발생.

### 5.2 개선안과 오리지널 코드 비교
| 구분 | 기존 구현 | 개선안(V250928R1) |
|------|-----------|-------------------|
| 열 순회 방식 | `for (col = 0; col < MATRIX_COLS; col++)` | `while (pending_columns)`으로 set bit만 순회 |
| 키맵 조회 횟수 | 항상 `MATRIX_COLS` | 실제 눌린 키 수만큼 |
| 비트 처리 | 시프트(`<<`)와 AND 조건 반복 | `__builtin_ctz`와 `pending &= pending - 1`로 O(#pressed) 반복 |

### 5.3 오리지널 의도 분석
- 키맵에 정의된 실제 키만 남겨 고스트 판정을 수행해, 미할당 위치(KC_NO)를 무시하려는 목적.
- 모든 열을 순회하는 단순 구조로 가독성을 확보하고, 다양한 `MATRIX_COLS` 설정에서도 동일한 동작을 보장.

### 5.4 부작용 검토
- **동적 키맵 호환성**: 여전히 `keycode_at_keymap_location()`을 호출해 최신 키맵 데이터를 참조하므로, VIA/Vial을 통한 실시간 레이아웃 변경과 충돌 없음.
- **컴파일러 의존성**: `__builtin_ctz`는 ARM-GCC에서 지원하며, 입력 값이 0인 경우는 루프 진입 조건으로 배제되어 안전.
- **고스트 판정 정확도**: 필터링 대상 열만 축소했을 뿐 반환 값은 기존과 동일하여 `has_ghost_in_row()`와 후속 로직이 그대로 동작.

### 5.5 수정/유지 판단
- **수정 필요**: `rowdata`에서 실제로 눌린 열만 순회하도록 비트 스캔 방식을 도입해, 대부분의 스캔(0~1키 입력)에서 불필요한 키맵 조회를 제거.
- **유지 항목**: 키맵 필터링 조건, `popcount_more_than_one()` 사용, 행 비교 및 `ghost_pending` 흐름은 기존 의도대로 보존.

### 5.6 재검토 결과
- `get_real_keys()`가 캐시된 마스크를 활용해 실제 눌린 열만 필터링하며, 동적 키맵 변경 시 무효화 훅을 통해 즉시 재계산됨을 확인했다.
- 키맵 열 순회가 눌린 키 수에 비례하도록 유지돼 성능·정확성 모두 만족하므로 추가 조정은 필요 없다.

## 6. V250928R2: 고스트 판정 시 물리 중복 열 기반의 키맵 필터 최소화

### 6.1 입력 흐름 재점검
- **추적 경로**: `keyboard_task()` → `matrix_task()` → `has_ghost_in_row()` → `get_real_keys()` → `keycode_at_keymap_location()`.
- **현상**: 특정 행(`rowdata`)에서 2키 이상이 눌린 경우, 다른 모든 행에 대해 `get_real_keys()`를 호출한다. 이때 물리적으로 공유하는 열이 2개 미만이더라도 키맵 필터를 수행해 불필요한 순회가 발생한다.

### 6.2 개선안(V250928R2)
| 구분 | 기존 구현 | 개선안 |
|------|-----------|--------|
| 중복 열 판단 | 즉시 `get_real_keys()` 호출 | 물리 행 데이터와 `rowdata`의 교집합을 먼저 계산 |
| 필터 조건 | 항상 키맵 필터 수행 | 물리 중복 열이 2개 이상일 때만 키맵 필터 수행 |
| 추가 연산 | 없음 | `overlap`에 대한 1비트 이하 빠른 종료 |

### 6.3 오리지널 의도 분석
- 고스트는 동일한 두 열이 두 개 이상의 행에서 동시에 활성화될 때만 발생한다는 전제를 유지.
- `get_real_keys()`로 미할당 키를 제거해, 실질적으로 사용자가 접근 가능한 키만 남기는 목적은 그대로 필요.

### 6.4 부작용 검토
- **고스트 누락 가능성**: 물리 중복 열이 2개 미만이면 직사각형을 이루지 못해 고스트가 발생하지 않으므로 안전하게 건너뛸 수 있다.
- **동적 키맵 호환성**: 키맵 필터를 완전히 제거하지 않고 조건부로 수행하므로 VIA/Vial 변경과 동일하게 동작한다.
- **성능 효과**: 대부분의 스캔에서 행 간 중복 열이 없으므로 `get_real_keys()` 호출 수가 크게 감소한다.

### 6.5 수정/유지 판단
- **수정 필요**: 물리 중복 열이 2개 미만인 경우 조기 종료를 도입해 키맵 필터링 호출을 줄인다.
- **유지 항목**: 고스트 판정 조건(`popcount_more_than_one()`), `ghost_pending` 처리 흐름, 이벤트 디스패치 구조는 기존 구현을 따른다.

### 6.6 재검토 결과
- 물리 중복 열 계산이 필터링 이전에 이뤄지더라도 `get_real_keys()`와의 조합으로 오검이 발생하지 않음을 확인했다.
- 대부분의 행 조합에서 불필요한 `get_real_keys()` 호출이 사라져 성능 향상이 유지되므로 추가 수정이 필요 없다.

## 7. V250928R3: 고스트 판정용 키맵 마스크 캐시 도입

### 7.1 이벤트 흐름 재점검
- **추적 경로**: `keyboard_task()` → `matrix_task()` → `has_ghost_in_row()` → `get_real_keys()` → `keycode_at_keymap_location()` → (동적 키맵일 경우) `dynamic_keymap_*` API.
- **현상**: 동일한 행 조합으로 고스트가 반복될 때마다 `get_real_keys()`가 베이스 레이어의 모든 키 위치를 조회한다. VIA/Vial 사용자 환경에서는 `keycode_at_keymap_location()`이 EEPROM을 통한 `dynamic_keymap_get_keycode()`까지 이어져 누적 지연이 발생한다.

### 7.2 개선안과 오리지널 코드 비교
| 구분 | 기존 구현 | 개선안(V250928R3) |
|------|-----------|-------------------|
| 키맵 조회 방식 | `rowdata`에 맞춰 매 호출마다 키맵 접근 | 행 단위 비트 마스크를 캐시에 저장해 필요 시에만 재계산 |
| 동적 키맵 반영 | 별도 고려 없음 | `dynamic_keymap_*` 경로에서 행 무효화 훅을 호출해 최신 상태 유지 |
| 메모리 사용 | 없음 | 행별 `matrix_row_t` 마스크 + dirty 플래그 |

### 7.3 오리지널 의도 분석
- `get_real_keys()`의 목적은 물리적으로 존재하지만 키맵에서 `KC_NO`로 비워진 위치를 제외해 고스트 판정의 정확도를 유지하는 것.
- 단순 반복 구조로 모든 호출이 동일 경로를 밟게 해, 동적 키맵과 정적 키맵 모두에서 동작 일관성을 확보하고 있었다.

### 7.4 부작용 검토
- **동적 키맵 변경 누락**: 캐시 사용 시 VIA/Vial을 통한 실시간 변경이 반영되지 않을 수 있으므로, `dynamic_keymap_set_keycode()`, `dynamic_keymap_reset()`, `dynamic_keymap_set_buffer()`에서 행/전체 무효화 훅을 호출해 즉시 dirty 처리한다.
- **초기화 시점**: 키보드 초기화 순서상 `get_real_keys()`가 호출되기 전까지 캐시를 준비하지 않아도 되므로, 지연 초기화(lazy init) 방식으로 구현해 불필요한 부트 비용을 방지.
- **메모리 Footprint**: `MATRIX_ROWS` 크기의 비트마스크와 플래그를 추가하지만, STM32H7S 여유 SRAM 관점에서 무시할 수준이며 실시간 경로에서 키맵 접근 횟수를 줄이는 효과가 더 크다.

### 7.5 수정/유지 판단
- **수정 필요**: 고스트 판정의 핵심인 키맵 필터 결과는 유지하면서, 반복 조회를 캐시로 대체해 EEPROM 접근 및 PROGMEM 읽기 부담을 제거.
- **유지 항목**: `has_ghost_in_row()`의 전체 로직, `popcount_more_than_one()` 조건, `ghost_pending` 흐름과 이벤트 디스패치 구조는 기존 구현과 동일하게 유지해 기능적 동등성을 확보한다.

### 7.6 재검토 결과
- `real_key_mask` 초기 접근 시 지연 초기화와 행 단위 dirty 플래그가 정상 동작하며, 동적 키맵 API 전반에서 무효화 훅이 호출되는지 확인했다.
- 캐시가 ISR 경로에서 접근되지 않아 경쟁 조건 우려가 없으므로 추가 보완이 필요 없다.

## 8. V250928R4: 키 이벤트 타임스탬프 재사용으로 `timer_read()` 호출 축소

### 8.1 입력 흐름과 기존 동작 점검
- **추적 경로**: `keyboard_task()` → `matrix_task()` → `action_exec()` → `action_tapping_process()`.
- **현상**: `matrix_task()`가 열 변화마다 `MAKE_KEYEVENT()`를 통해 `timer_read()`를 호출한다. 동일 스캔 안에서 여러 키 변화가 발생하면 `timer_read()`가 연속 호출되어 타이머 레지스터 접근이 반복된다.
- **비용**: 8000Hz 스캔에서는 스위치가 몰려 눌릴 때마다 `timer_read()`가 증가하며, ARM 사이드에서 16비트 타이머 레지스터를 읽는 비용이 누적된다.

### 8.2 개선안과 오리지널 코드 비교
| 구분 | 기존 구현 | 개선안(V250928R4) |
|------|-----------|------------------|
| 타임스탬프 획득 | `MAKE_KEYEVENT()` 호출마다 `timer_read()` 실행 | 행 단위로 `keyevent_t`를 미리 구성하고 타임스탬프를 한 번만 읽어 재사용 |
| 이벤트 생성 | 매번 매크로 확장을 통해 구조체 생성 | `keyevent_t`를 스택에 준비 후 열 인덱스/상태만 갱신 |
| 부가 처리 | 없음 | 주석으로 동일 스캔 공유 타임스탬프 의도 명시 |

### 8.3 오리지널 의도 분석
- QMK는 이벤트별 타임스탬프를 유지해 탭-홀드 판정 및 오토시프트 타이머가 동작하도록 설계되었다.
- `MAKE_KEYEVENT()`를 사용한 이유는 코드 가독성과 기존 QMK 포팅 유지 목적이었다.

### 8.4 부작용 검토
- **시간 해상도**: QMK의 `timer_read()`는 ms 단위라 동일 스캔에서 연속 호출해도 대부분 동일 값을 반환한다. 타임스탬프 공유가 기존 동작과 일치한다.
- **타이머 동기화**: 스캔 도중 1ms 경계가 넘어가도 행 단위로 갱신되므로 이벤트 순서가 역전되지 않는다.
- **동적 기능 영향**: `action_tapping_process()` 및 오토시프트 등은 ms 단위 차이만 비교하므로 행 단위 공유값으로도 로직 보존.

### 8.5 수정/유지 판단
- **수정 필요**: `timer_read()` 호출 수를 키 변화 수에서 행 변화 수로 축소해 타이머 접근 비용을 줄이고, 동일 스캔 내 이벤트는 공유 타임스탬프로 처리한다.
- **유지 항목**: `switch_events()` 호출, 고스트 판정 흐름, `process_keypress` 조건 판단 등은 그대로 유지해 기능적 호환성을 확보한다.

### 8.6 재검토 결과
- 행 단위로 공유된 타임스탬프가 탭-홀드, 콤보, 오토시프트 등 ms 단위 비교 로직과 충돌하지 않음을 재확인했다.
- `keyevent_t`를 스택에서 재사용해도 이벤트 순서가 유지되므로 추가 수정이 필요 없다.

## 9. V250928R5: 스캔 단위 타임스탬프 공유로 `timer_read()` 추가 축소

### 9.1 입력 흐름 재검토
- **추적 경로**: `keyboard_task()` → `matrix_task()` → `action_exec()` → `action_tapping_process()`.
- **현황**: V250928R4 적용 후 행 단위로 `timer_read()`를 공유하지만, 동일 스캔에서 여러 행이 동시에 변화하면 행 수만큼 `timer_read()`가 호출된다.
- **비용 요인**: 8000Hz 스캔 환경에서 여러 행에 변화가 몰리면 16비트 타이머 레지스터 접근이 반복되어 여전히 눈에 띄는 비용이 남는다.

### 9.2 개선안과 오리지널 코드 비교
| 구분 | 기존 구현(V250928R4) | 개선안(V250928R5) |
|------|----------------------|-------------------|
| 타임스탬프 갱신 | 행 진입 시마다 `timer_read()` | 스캔 시작 시 1회 `timer_read()` 후 모든 이벤트 공유 |
| 이벤트 구성 | 행 단위로 `keyevent_t` 초기화 | 스캔 시작 시 기본 구조체를 준비하고 행/열만 갱신 |
| 타임스탬프 일관성 | 행 내 이벤트만 동일 | 동일 스캔에서 생성된 모든 이벤트가 동일 |

### 9.3 오리지널 의도 분석
- QMK는 이벤트마다 시간값을 부여해 탭-홀드, 오토시프트, 콤보 등 시간 기반 로직을 유지하려 했다.
- `timer_read()` 해상도는 ms 단위라 동일 스캔 내 여러 호출이 이루어져도 대부분 동일 값을 반환했으며, 행 단위 공유로 이미 시간 분해능이 크게 줄어든 상태였다.
- 따라서 스캔 전체가 동일 타임스탬프를 사용해도 원래 의도(스캔 간 상대 시간 유지)와 충돌하지 않는다.

### 9.4 부작용 검토
- **이벤트 순서**: 동일 스캔 내 이벤트가 같은 시간값을 가지지만, 행/열 처리 순서는 그대로 유지되어 후속 로직에서 선입선출 순서가 보장된다.
- **경계 조건**: 스캔 중 1ms 경계를 넘어도 단 한 번의 `timer_read()`로 값을 얻으므로 기존 대비 더 일관된(단조 증가) 시간값을 제공한다.
- **동적 기능 영향**: `action_tapping_process()`와 `combo`, `auto_shift` 등은 `timer_elapsed()`를 사용해 ms 단위 비교만 수행하므로 스캔 단위 공유와 기능적 차이가 없다.

### 9.5 수정/유지 판단
- **수정 필요**: `timer_read()` 호출을 스캔당 1회로 축소해 행 변화가 몰릴 때의 타이머 접근 비용을 추가로 제거하고, 타임스탬프는 스캔 단위로 공유한다.
- **유지 항목**: `action_exec()` 호출 위치, `switch_events()` 흐름, 고스트 판정과 디바운스 연계 로직은 기존 구조를 유지한다.

### 9.6 재검토 결과
- 스캔 시작 시 한 번만 읽은 타이머 값이 모든 키 이벤트에 공유돼도 USB 타스크 및 tick 이벤트와 시간 단조성을 유지함을 검증했다.
- 타이머 경계에서 값이 변해도 스캔 단위로만 갱신되므로 추가 보완이 필요 없다.
