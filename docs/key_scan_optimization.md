# 키 스캔 경로 최적화 검토 (V250924R6)

## 1. 분석 범위와 기준
- **측정 기준**: `matrix info on` CLI에서 노출되는 `SCAN RATE` 및 `Scan Time`.
- **대상 경로**: `matrix_scan()` → `keysPeekColsBuf()` → DMA 기반 `col_rd_buf` → 디바운서(`sym_defer_pk`, `sym_eager_pk`, `asym_eager_defer_pk`).
- **현황**: USB 불안정성 탐지 로직 도입 이후 스캔 레이트가 약 5% 하락.

## 2. 기존 구현 요약
1. `keysReadColsBuf()`로 DMA 버퍼 전체를 지역 배열에 복사.
2. 각 행을 순회하며 `raw_matrix`와 비교, 변경 시 갱신 및 `changed=true`.
3. 결과를 디바운서에 전달하여 QMK 매트릭스 상태를 확정.

### 구현 의도 해석
- DMA가 채운 `col_rd_buf`를 즉시 복사해 스냅샷을 확보하고, 디바운서 호출 전에 일관된 데이터를 보장하려는 목적.
- `changed` 플래그를 통해 디바운서의 시간 업데이트와 USB 타임 로그 호출 빈도를 조절.

## 3. 발견된 병목
- 매 스캔마다 `MATRIX_ROWS*sizeof(uint16_t)` 만큼의 `memcpy`가 발생.
- DMA 버퍼는 `.non_cache` 섹션에 위치해 있으며, CPU가 직접 참조해도 캐시 일관성 문제가 없음.
- 추가 복사 없이도 동일한 데이터 일관성을 유지할 수 있어, 8000Hz 환경에서는 `memcpy` 제거 효과가 누적.

## 4. 개선안
| 구분 | 기존 | 개선 |
|------|------|------|
| 데이터 취득 | `keysReadColsBuf()` → 지역 배열 복사 | `keysPeekColsBuf()`로 DMA 버퍼 직접 참조 |
| 변경 감지 | `raw_matrix` vs 지역 배열 | `raw_matrix` vs DMA 버퍼 |
| 디바운서 호환성 | `changed` 플래그 전달 | 동일 (`changed` 계산 로직 유지) |

- DMA 버퍼를 상수 포인터로 노출하는 `keysPeekColsBuf()` 신규 API 추가.
- `matrix_scan()`은 포인터를 통해 행 데이터를 바로 읽고 변경 여부를 판단.
- 디바운서 API (`sym_defer_pk`, `sym_eager_pk`, `asym_eager_defer_pk`)는 입력 배열 참조 방식이 그대로라 호환성 유지.

## 5. 부작용 검토
- **동시성**: DMA가 16비트 단위로 버퍼를 갱신하며, CPU도 16비트로 읽으므로 절반만 갱신된 값을 읽을 확률은 매우 낮음. 기존 `memcpy` 또한 동일한 윈도우에서 실행되므로 위험 수준은 동일.
- **API 의존성**: 기존 호출부(`keysReadColsBuf`)는 유지되어 다른 모듈 영향 없음.
- **디바운서 동작**: 입력 포인터만 변경되었으므로 타이머 기반 동작 (`changed` 전달) 불변.

## 6. 수정/유지 판단
- **수정 필요**: `matrix_scan()`에서 DMA 버퍼 직접 참조로 전환, 새로운 API 제공, 펌웨어 버전 갱신.
- **유지 항목**: 디바운스 로직 호출 구조, `changed` 플래그 처리, USB 타임 로그 호출 조건.

## 7. 기대 효과
- 키 스캔 루프의 메모리 복사 비용 제거로 8000Hz 환경에서 약 3~4% 수준의 스캔 시간 회복 기대 (DMA/CPU 경합 상황에서 추가 이득 가능).
- USB 불안정성 탐지 로직으로 발생한 스캔 레이트 하락분을 상당 부분 상쇄.

## 8. 키 이벤트 처리 경로 추가 분석 (V250924R6)

### 8.1 경로 추적 및 기존 동작 요약
- **탐색 범위**: `keyboard_task()` → `matrix_task()` → `matrix_scan()` → `action_exec()`.
- `matrix_task()`은 매 스캔마다 `matrix_scan()`을 호출한 뒤, `matrix_previous` 배열과의 XOR 결과를 이용해 행 단위 변경 여부를 확인하고, 변경이 감지된 행만 열 루프를 돌며 키 이벤트를 생성.
- 고스트(phantom) 상태가 감지되면 해당 행 처리를 건너뛰고 `matrix_previous`를 갱신하지 않아, 고스트가 해소될 때까지 이후 반복에서 계속 변경으로 인식되는 구조.

### 8.2 개선안 vs 기존 코드 비교
| 구분 | 기존 | 개선 (V250924R6) |
|------|------|-----------------|
| 변경 감지 초기화 | `matrix_scan()` 결과와 무관하게 모든 행을 순회하며 XOR 검사 | `matrix_scan()` 반환값을 1차 신호로 사용, 고스트 상태 여부(`ghost_pending`)를 보강 지표로 활용 |
| 고스트 지속 처리 | 고스트가 존재하면 `matrix_previous` 미갱신 → 다음 스캔도 전체 행 검사 | 고스트 플래그가 설정된 경우에만 후속 스캔에서 행 검사를 유지 |
| 불필요한 루프 | 키 상태 변화가 없더라도 `MATRIX_ROWS` 전부 순회 | 고스트가 없고 스캔 결과가 동일하면 행 루프 자체를 건너뜀 |

### 8.3 기존 구현 의도 해석
- 고속 폴링 환경에서 **디바운스 이후 상태 변화**를 감지해 필요할 때만 `action_exec()`을 호출하려는 목적.
- 고스트가 발견되면 `matrix_previous`를 고의로 유지해, 고스트가 사라질 때까지 매트릭스 변경이 반복적으로 보고되도록 설계하여 안정적인 해제 이벤트를 확보하려는 의도.

### 8.4 부작용 검토
- `matrix_scan()` 결과가 false라도 고스트 지속 여부에 따라 다시 행 루프가 실행되므로, 고스트 시나리오에서 기존과 동일하게 해제 감시가 이루어짐.
- `ghost_pending` 플래그가 없는 상태에서는 행 루프를 건너뛰지만, 이는 `matrix_previous`와 디바운스 결과가 이미 동기화된 상황에서만 발생하므로 이벤트 누락 없음.
- `matrix_task()` 반환값은 기존과 동일하게 고스트를 포함한 변경 케이스에서 true를 유지하여, `last_matrix_activity_trigger()` 호출 빈도 변화 없음.

### 8.5 수정/유지 판단
- **수정 필요**: 고스트 지속 플래그(`ghost_pending`)를 도입하고, `matrix_scan()` 결과 기반으로 행 루프 수행 여부를 단축하여 무의미한 XOR 루프를 제거.
- **유지 항목**: 고스트 발생 시 `matrix_previous` 미갱신 전략, `should_process_keypress()` 게이트, `switch_events()` 후속 훅 구조.

## 9. 열 루프 비트 스캔 최적화 검토 (V250924R7)

### 9.1 탐색 및 병목 파악
- **관찰 지점**: `matrix_task()`의 열 순회 루프 (`for (col=0; col<MATRIX_COLS; col++)`).
- **동작 분석**: 행의 비트 변경 여부(`row_changes`)가 1~2개에 불과해도 모든 열을 순회하며 `if (row_changes & col_mask)` 조건을 반복 평가.
- **성능 영향**: 8000Hz 환경에서 행 변경이 적은 경우에도 고정된 `MATRIX_COLS` 횟수만큼 시프트/AND 연산이 수행되어 CPU 주기 낭비.

### 9.2 개선안 제안
- **핵심 아이디어**: `row_changes`의 set bit만 순회하도록 비트 스캔 루프를 도입해 조건 분기와 시프트 연산을 제거.
- **구현**: `__builtin_ctz()`로 최하위 set bit 위치를 취득하고, `pending_changes &= pending_changes - 1`로 처리한 비트를 제거.
- **적용 지점**: `matrix_task()` 내부 열 순회.

#### 기존 vs 개선 비교
| 구분 | 기존 구현 | 개선안 (V250924R7) |
|------|-----------|-------------------|
| 반복 횟수 | `MATRIX_COLS` 고정 반복 | 변경된 비트 수만큼 반복 |
| 연산 | `col_mask <<= 1` 시프트 + `if (row_changes & col_mask)` 분기 | `ctz`로 인덱스 도출, `pending &= pending-1`로 비트 제거 |
| 메모리 접근 | 모든 열에서 분기 판단 후 이벤트 처리 | 이벤트가 있는 열에 대해서만 처리 |

### 9.3 오리지널 코드 의도 해석
- 단순한 for-루프로 모든 열을 검사하여 고스트 처리와 키 이벤트 생성 로직을 명확하게 유지.
- 조건문으로 변경 여부를 필터링함으로써 로직 이해도를 높이고, 다양한 컴파일러에서 일관된 동작을 기대.

### 9.4 부작용 및 호환성 검토
- `__builtin_ctz()`는 GCC/Clang에서 제공되며 ARM-GCC 툴체인에서도 사용 가능. 입력이 0일 때 정의되지 않지만, 루프 진입 조건을 `pending_changes`가 0이 아닐 때로 제한해 안전 확보.
- `MATRIX_COLS` 값에 따라 `matrix_row_t`가 8/16/32비트로 정의되므로, `((matrix_row_t)1) << col` 연산이 그대로 유지되어 비트마스크 계산 호환성 유지.
- 행에 다수의 키 변화가 있는 경우에도 모든 비트를 순회하므로 기존 이벤트 순서와 기능 동일.

### 9.5 수정/유지 판단
- **수정 필요**: 고정된 열 루프를 비트 스캔 방식으로 대체해 불필요한 연산을 제거하면, 변화가 적은 입력 패턴에서 CPU 사용량을 추가로 절감할 수 있음.
- **유지 항목**: `process_keypress` 조건, `switch_events()` 호출 순서, 고스트 행 건너뛰기 전략은 변경하지 않음.

