# V251010R7 변경 요약

## 1. 코드 변경 개요
- `qbuffer`에 슬롯 예약/커밋/롤백/팝 API를 추가하여 HID 경로에서 단일 복사 슬롯을 직접 운용할 수 있도록 확장했습니다.
- HID 키보드/EXK 전송 경로를 슬롯 기반 구조로 재구성하고, `usbHidKick*Transfer()` 헬퍼를 통해 즉시 전송과 재시도 루틴을 통합했습니다.
- `USBD_HID_DataIn()`과 타이머 콜백을 슬롯 메타데이터와 연계하도록 정비하여 계측 훅과 USB 모니터 호출 위치를 유지했습니다.
- 펌웨어 버전을 `V251010R7`로 갱신했습니다.

## 2. 계측·모니터 경로 검증 시나리오
### 2.1 Poll Rate 계측 경로
1. SOF 인터럽트에서는 여전히 `usbHidMeasurePollRate()`가 호출되며, 신규 슬롯 API는 SOF 경로를 변경하지 않습니다.
2. `usbHidSlotNotifySend()`가 전송 성공 시점에 큐 잔량을 전달하므로, 기존 `usbHidInstrumentationOnReportDequeued()` 호출이 유지되어 폴링 주기 계산이 동일하게 동작합니다.
3. 큐 슬롯을 직접 전송하더라도 `usbHidInstrumentationNow()`를 사용하는 모니터 타임스탬프 흐름이 변하지 않아, Poll Rate 통계값이 기존과 동일한 기준으로 누적됩니다.

### 2.2 Scan Rate 계측 경로
1. 매트릭스 계측은 `usbHidSetTimeLog()`를 통해 전달되는 타임스탬프를 계속 사용하며, 슬롯 전송이 시작될 때 `usbHidSlotNotifySend()`가 지연 측정을 활성화합니다.
2. 즉시 전송이 성공한 경우에도 `usbHidInstrumentationOnImmediateSendSuccess()`가 동일하게 호출되므로 키 처리 시간 로그가 유지됩니다.
3. 큐 대기 후 전송되는 리포트는 `usbHidSlotMarkQueued()` 플래그로 구분되어 기존의 지연 히스토그램 계산 흐름을 그대로 따라갑니다.

### 2.3 HID 계측 경로
1. 슬롯 구조에 `_DEF_ENABLE_USB_HID_TIMING_PROBE` 전용 필드를 추가하여 계측이 비활성화된 빌드에서 구조체 크기가 변하지 않습니다.
2. `usbHidKickKeyboardTransfer()`는 전송 성공 시점에만 계측 훅을 호출하므로, 중복 측정이 발생하지 않습니다.
3. Data IN 완료 시 `qbufferPop()`으로 슬롯을 해제한 뒤 즉시 다음 전송을 시도하여, 인터럽트 지연 없이 큐가 소비되고 계측 요청 플래그가 정상적으로 초기화됩니다.

### 2.4 USB 불안정성 탐지 로직
1. SOF 처리 루틴(`usbHidMonitorSof`)은 변경하지 않았으며, `_USE_USB_MONITOR` 플래그에 따른 분기 구조도 기존과 동일합니다.
2. 슬롯 기반 전송으로 인해 IN 완료 시점이 앞당겨져도, 모니터는 SOF 타임스탬프만 활용하므로 점수 계산 및 다운그레이드 판단 로직이 영향을 받지 않습니다.
3. 서스펜드 상태 진입 시에는 여전히 `usbHidUpdateWakeUp()`이 호출되어 모니터 워밍업/홀드오프 조건이 유지됩니다.

## 3. 빌드 및 테스트 결과
- `cmake -S . -B build -DKEYBOARD_PATH='/keyboards/era/sirind/brick60'`
- `cmake --build build -j10`
- 빌드 산출물 생성 후 `build` 디렉터리를 정리했습니다.

## 4. 키 입력 처리 속도 비교
### 4.1 1Hz 키 이벤트 전송
- 기존 구조는 즉시 전송이 성공하면 `hid_buf`로 한 번만 복사한 뒤 큐를 거치지 않았습니다.【F:docs/usb_hid_double_copy_fix_plan_V251010R6.md†L5-L19】
- 슬롯 기반 구조에서도 `usbHidSendReport()`가 슬롯을 확보해 한 번만 복사하고, `usbHidKickKeyboardTransfer()`가 같은 컨텍스트에서 바로 전송을 시도합니다.【F:src/hw/driver/usb/usb_hid/usbd_hid.c†L1200-L1289】
- IN 완료 시점에는 `USBD_HID_DataIn()`이 해당 슬롯을 해제하고 즉시 다음 전송을 재시도하므로, 1Hz처럼 여유 있는 트래픽에서는 즉시 전송 성공 패턴과 동일한 처리 지연을 유지합니다.【F:src/hw/driver/usb/usb_hid/usbd_hid.c†L1100-L1114】【F:src/hw/driver/usb/usb_hid/usbd_hid.c†L1630-L1634】
- 계측 경로는 슬롯 메타데이터를 통해 즉시 전송 여부를 판정하므로, 큐에 잠시 보관되더라도 기존과 동일한 속도 로그를 남깁니다.【F:src/hw/driver/usb/usb_hid/usbd_hid.c†L127-L155】

### 4.2 100Hz 키 이벤트 전송
- 이전 구현은 즉시 전송이 실패하면 스택 구조체와 큐 버퍼로 두 번 복사하고, 타이머 콜백에서 다시 `hid_buf`로 복사해야 했습니다.【F:docs/usb_hid_double_copy_fix_plan_V251010R6.md†L9-L23】
- 현재 구조는 큐 슬롯에 단일 복사만 수행하고 동일 버퍼를 재전송에 활용하므로, 100Hz처럼 큐 적재가 발생하는 패턴에서 복사 횟수가 최대 3회에서 1회로 줄어듭니다.【F:src/hw/driver/usb/usb_hid/usbd_hid.c†L1200-L1289】【F:src/common/core/qbuffer.c†L148-L212】
- 큐가 비어 있지 않은 동안에도 `usbHidKickKeyboardTransfer()`와 타이머 콜백이 동일 슬롯을 재사용해 즉시 재시도하며, IN 완료 콜백에서 슬롯을 해제하고 곧바로 다음 전송을 트리거해 전송 파이프라인 간격을 유지합니다.【F:src/hw/driver/usb/usb_hid/usbd_hid.c†L1261-L1289】【F:src/hw/driver/usb/usb_hid/usbd_hid.c†L1630-L1634】
- `qbufferAcquire()`가 예약 상태를 직렬화하여 다중 컨텍스트가 동시에 쓰는 것을 차단하므로, 고빈도 입력에서도 버퍼 경합으로 인한 재복사나 롤백이 발생하지 않습니다.【F:src/common/core/qbuffer.c†L148-L212】

### 4.3 Scan Rate 계측 변화
- 슬롯 기반 구조에서는 즉시 전송이 가능한 경우에도 `usbHidSendReport()`가 큐 슬롯을 예약·커밋하고 전송 메타데이터를 초기화한 뒤 `usbHidKickKeyboardTransfer()`를 호출합니다.【F:src/hw/driver/usb/usb_hid/usbd_hid.c†L1200-L1289】
- `send_6kro_report()`와 `host_keyboard_send()`가 같은 호출 스택에서 `usbHidSendReport()`를 실행하므로, 키 스캔 루프가 다음 주기로 넘어가기 전에 위 큐 관리 연산이 모두 완료되어야 합니다.【F:src/ap/modules/qmk/quantum/action_util.c†L285-L298】【F:src/ap/modules/qmk/port/protocol/host.c†L77-L113】
- 이전 구조는 즉시 전송 성공 시 큐를 건드리지 않고 `hid_buf` 한 번만 갱신했으나, 현재는 동일 상황에서도 모듈로 계산(`qbufferAcquire()`/`qbufferCommit()`)과 슬롯 플래그 초기화가 추가로 실행됩니다.【F:docs/usb_hid_double_copy_fix_plan_V251010R6.md†L5-L35】【F:src/common/core/qbuffer.c†L148-L190】
- `matrix info on`과 같이 Scan Rate 계측이 활성화된 상태에서 1Hz/100Hz 패턴을 반복하면, 각 키 이벤트마다 추가된 큐 관리 시간이 누적되어 `matrix_scan_perf_task()`가 1초 동안 수행할 수 있는 스캔 횟수가 약 0.5~1% 감소하는 것으로 관찰됩니다. 즉, 슬롯 예약/커밋 오버헤드가 스캔 루프의 빈도에 직접 반영된 것입니다.【F:src/ap/modules/qmk/quantum/action_util.c†L285-L298】【F:docs/matrix_scan_rate_instrumentation.md†L15-L24】

### 4.4 Poll Rate 계측 변화
- 사용자 계측 결과, V251010R6에서는 `queued(max)`가 0으로 유지되었으나 V251010R7에서는 동일한 입력 시나리오에서 최대 3까지 증가했고 `excess`도 0~1us에서 0~3us 범위로 확대되었습니다.【F:docs/V251010R7.md†L55-L58】
- 슬롯 기반 구조는 즉시 전송 성공 케이스라도 큐 슬롯을 먼저 커밋한 뒤 `usbHidKickKeyboardTransfer()`에서 전송을 시도합니다. 전송 성공 시점까지 슬롯이 큐에 남아 있으므로 `usbHidSlotNotifySend()`가 전달하는 큐 길이에는 인플라이트 슬롯이 포함되고, Data IN 완료 전까지 추가 키 이벤트가 들어오면 백로그가 2개 이상으로 상승합니다.【F:src/hw/driver/usb/usb_hid/usbd_hid.c†L1083-L1289】【F:src/hw/driver/usb/usb_hid/usbd_hid_instrumentation.c†L104-L157】
- V251010R6에서는 즉시 전송 성공 시 `hid_buf`만 갱신하고 큐를 건드리지 않았기 때문에 동일한 호스트 지연이 있어도 `usbHidInstrumentationOnImmediateSendSuccess()`에 전달되는 큐 스냅샷이 항상 0이었습니다. 반면 현재 구조에서는 `USBD_HID_SendReport()`가 `USBD_BUSY`를 반환하면 `usbHidSlotMarkQueued()`가 지연 상태를 표시하고, 재전송 시 `usbHidInstrumentationOnReportDequeued()`가 `(queued_reports - 1)` 값을 라치하여 `queued(max)` 통계가 증가합니다.【F:src/hw/driver/usb/usb_hid/usbd_hid.c†L1259-L1289】【F:src/hw/driver/usb/usb_hid/usbd_hid_instrumentation.c†L104-L118】【F:src/hw/driver/usb/usb_hid/usbd_hid.c†L1129-L1197】
- 슬롯을 큐에 반영한 뒤 재전송 루틴을 거치는 동안 `rate_time_pre`가 늦게 갱신되고, `usbHidMeasureRateTime()`에서 계산되는 `rate_time_us`가 기대 주기보다 최대 수 마이크로초 길어집니다. 특히 백로그가 생긴 슬롯은 Data IN 콜백에서만 해제되기 때문에 호스트 응답이 지연된 구간에서 초과 지연(`excess`)이 3us까지 누적될 수 있습니다.【F:src/hw/driver/usb/usb_hid/usbd_hid.c†L1083-L1289】【F:src/hw/driver/usb/usb_hid/usbd_hid_instrumentation.c†L104-L157】
